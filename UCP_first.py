from pyomo.environ import *
import random

model = ConcreteModel()

############### DATA ###############

# Set of generators and time horizon
model.Generators = RangeSet(1, 25)  
model.TimePeriods = RangeSet(1, 24) # h

# Random demand for each time step
Demand = {t: random.uniform(50, 600) for t in model.TimePeriods} # MW

# Fuel and start-up costs
Fuel_Cost = {g: random.uniform(20, 25) for g in model.Generators}  # (USD/MW)
StartUp_Cost = {g: random.uniform(100, 110) for g in model.Generators}  
ShutDown_Cost = {g: random.uniform(100, 110) for g in model.Generators}  

# Operational parameters for our generators
Min_Up_Time = {g: random.randint(3, 5) for g in model.Generators} # h
Min_Down_Time = {g: random.randint(4, 8) for g in model.Generators} # h
Min_Generation = {g: random.uniform(10, 40) for g in model.Generators} # MW
Max_Generation = {g: random.uniform(50, 180) for g in model.Generators} # MW
RampUp_Rate = {g: Max_Generation[g] * 0.3 for g in model.Generators}  # 30% of max generation
RampDown_Rate = {g: Max_Generation[g] * 0.3 for g in model.Generators}  # 30% of max generation
# Emission rates (example values in kg CO2/MWh)
Emission_Rate = {g: random.uniform(0.5, 1.0) for g in model.Generators}
# Individual emission limits for each generator (example values) for the entire time horizon
Individual_Emission_Limits = {g: 500 for g in model.Generators}  # kg of CO2 for each generator

# Match start-up costs to each generator
model.StartupCost = Param(model.Generators, initialize=StartUp_Cost, within=NonNegativeReals)

# Match shutdown costs to each generator
model.ShutDownCost = Param(model.Generators, initialize=ShutDown_Cost, within=NonNegativeReals)

############### VARIABLES ###############

# Binary variable for generator status (1 if on, 0 if off)
model.OnOff = Var(model.Generators, model.TimePeriods, domain=Binary)

# Power generated by each generator at each time step
model.Generation = Var(model.Generators, model.TimePeriods, domain=NonNegativeReals)

# Variables to indicate if a generator is switched on or off at a time step
model.StartUp = Var(model.Generators, model.TimePeriods, domain=Binary)
model.ShutDown = Var(model.Generators, model.TimePeriods, domain=Binary)

############### CONSTRAINTS ###############

# Load demand constraint must be satisfied for each time step
def demand_constraint(model, t):
    return sum(model.Generation[g, t] for g in model.Generators) >= Demand[t]
model.DemandConstr = Constraint(model.TimePeriods, rule=demand_constraint)

# Minimum and Maximum Generation constraints
def min_generation_constraint(model, g, t):
    return model.Generation[g, t] >= Min_Generation[g] * model.OnOff[g, t]
def max_generation_constraint(model, g, t):
    return model.Generation[g, t] <= Max_Generation[g] * model.OnOff[g, t]

model.MinGenerationConstr = Constraint(model.Generators, model.TimePeriods, rule=min_generation_constraint)
model.MaxGenerationConstr = Constraint(model.Generators, model.TimePeriods, rule=max_generation_constraint)

# Constraint to define StartUp and ShutDown variables
def startup_shutdown_rule(model, g, t):
    if t == 1:
        # For the first time period, assume generators are off in the previous period
        return model.StartUp[g, t] - model.ShutDown[g, t] == model.OnOff[g, t]
    else:
        return model.StartUp[g, t] - model.ShutDown[g, t] == model.OnOff[g, t] - model.OnOff[g, t-1]

model.StartupShutdownConstr = Constraint(model.Generators, model.TimePeriods, rule=startup_shutdown_rule)

# Minimum Up Time Constraint
def min_up_time_rule(model, g, t):
    if t >= Min_Up_Time[g]:
        return sum(model.StartUp[g, tp] for tp in range(max(1, t - Min_Up_Time[g] + 1), t + 1)) <= model.OnOff[g, t]
    else:
        return Constraint.Skip

model.MinUpTimeConstr = Constraint(model.Generators, model.TimePeriods, rule=min_up_time_rule)

# Minimum Down Time Constraint
def min_down_time_rule(model, g, t):
    if t >= Min_Down_Time[g]:
        return sum(model.ShutDown[g, tp] for tp in range(max(1, t - Min_Down_Time[g] + 1), t + 1)) <= 1 - model.OnOff[g, t]
    else:
        return Constraint.Skip

model.MinDownTimeConstr = Constraint(model.Generators, model.TimePeriods, rule=min_down_time_rule)

# Ramping Up Constraint
def ramp_up_constraint(model, g, t):
    if t > 1:
        return model.Generation[g, t] - model.Generation[g, t-1] <= RampUp_Rate[g]
    else:
        return Constraint.Skip  # Skip the first time period

model.RampUpConstr = Constraint(model.Generators, model.TimePeriods, rule=ramp_up_constraint)

# Ramping Down Constraint
def ramp_down_constraint(model, g, t):
    if t > 1:
        return model.Generation[g, t-1] - model.Generation[g, t] <= RampDown_Rate[g]
    else:
        return Constraint.Skip  # Skip the first time period

model.RampDownConstr = Constraint(model.Generators, model.TimePeriods, rule=ramp_down_constraint)

# Constraint for individual generator emissions
def individual_emission_constraint(model, g):
    return sum(model.Generation[g, t] * Emission_Rate[g] for t in model.TimePeriods) <= Individual_Emission_Limits[g]

model.IndividualEmissionConstr = Constraint(model.Generators, rule=individual_emission_constraint)

############### OBJECTIVE IS TO MINIMIZE OVERALL COST ###############

def objective_rule(model):
    return sum(model.Generation[g, t] * Fuel_Cost[g] for g in model.Generators for t in model.TimePeriods) + \
           sum(model.StartUp[g, t] * model.StartupCost[g] for g in model.Generators for t in model.TimePeriods) + \
           sum(model.ShutDown[g, t] * model.ShutDownCost[g] for g in model.Generators for t in model.TimePeriods)

model.Objective = Objective(rule=objective_rule, sense=minimize)

solver = SolverFactory('gurobi')  
results = solver.solve(model, tee=True)

model.Objective.display()

import matplotlib.pyplot as plt

# Extracting generator status and generation values
generator_status = {(g, t): model.OnOff[g, t].value for g in model.Generators for t in model.TimePeriods}
generation_amount = {(g, t): model.Generation[g, t].value for g in model.Generators for t in model.TimePeriods}

import matplotlib.pyplot as plt
import numpy as np

# Prepare data for plotting
time_periods = list(model.TimePeriods)
generators = list(model.Generators)
status_matrix = np.zeros((len(generators), len(time_periods)))
generation_matrix = np.zeros((len(generators), len(time_periods)))

for g in generators:
    for t in time_periods:
        status_matrix[g-1, t-1] = generator_status[g, t]
        generation_matrix[g-1, t-1] = generation_amount[g, t] if generator_status[g, t] > 0 else 0

# Plotting
fig, ax = plt.subplots(figsize=(15, 8))

# Plot for each generator
for idx, g in enumerate(generators):
    ax.bar(time_periods, generation_matrix[idx, :], bottom=np.sum(generation_matrix[:idx, :], axis=0), label=f'Generator {g}')

# Customize plot
ax.set_xlabel('Time Periods')
ax.set_ylabel('Generation Amount')
ax.set_title('Generator Status and Generation Amount Over Time')
ax.set_xticks(time_periods)
ax.legend()

plt.show()